#! /bin/bash
#
# 	Part of kde-service-menu-revideo Version 0.1.1
# 	Copyright (C) 2018-2019 Giuseppe Benigno <giuseppe.benigno(at)gmail.com>
# 	Copyright (C) 2024 <fashim99.(at)gmail.com>
#
# 	This program is free software: you can redistribute it and/or modify
# 	it under the terms of the GNU General Public License as published by
# 	the Free Software Foundation, either version 3 of the License, or
# 	(at your option) any later version.
#
# 	This program is distributed in the hope that it will be useful,
# 	but WITHOUT ANY WARRANTY; without even the implied warranty of
# 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# 	GNU General Public License for more details.
#
# 	You should have received a copy of the GNU General Public License
# 	along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

#### languages strings messages #################
# Syntax for strings name is: msg_[$format]_$window_[$section]
# For languages as sr@Latn use srLatn

new_line="
"

load_language_en_US () {
	### Messages

	msg_common_software_not_found_title="Software not found"
	msg_common_ffmpeg_not_found_text="Software Ffmpeg not found! Please, install it."
	msg_common_rife_not_found_text="Software RIFE not found! Please, install it."
	msg_common_dain_not_found_text="Software DAIN not found! Please, install it."
	msg_common_action_not_found_text="The requested action is not implemented."
	msg_common_overwrite_text="In case the images to be saved have the same name as those to be processed,${new_line}do you want to overwrite them?"
	msg_common_abort="Operation interrupted by the user."
	msg_common_file_not_found="File \"${name}\" not found!"
	msg_common_name_error="The file name \"${name}\" does not match a recognized format for a date.${new_line}${new_line}The name must be of the type: YYYY-MM-DD_HHMMSS.jpg"
	msg_common_start="Initialising ... "
	msg_common_progress_text="Processing file $processed of $quantity ($(basename "${input}"))"
	msg_common_finish_ok="Done."
	msg_common_finish_error="An error has occurred."
	msg_common_transparent_unsupported_text="This codec format does not support transparency.${new_line}Convert to an alpha codec."
# 	msg_common_details="Details:"

	msg_compress_title="Image compression with quality \"${value}\""
	msg_compress_quality_input_text="Type the quality:"
	msg_compress_finish_title="Compression of \"${name}\""

	msg_gpu_interpolate_input_text="One or multiple compatible GPU(s) were detected.${new_line}Choose a model for interpolation ($def_model by default).${new_line}${new_line}'Minterpolate' runs exclusively on CPU, which is slow!${new_line}"

	msg_afallback_encode_input_text="'${base}.${ext}''s audio codec is not known from revideo.${new_line}It will fallback to either a lossless codec (PCM) or a lossy one (Opus)${new_line}($def_afallback by default)${new_line}${new_line}Choose one:${new_line}"
	msg_vfallback_encode_input_text="'${base}.${ext}''s video codec is not known from revideo.${new_line}It will fallback to either a lossless codec (ProRes) or a lossy one (h264)${new_line}($def_vfallback by default)${new_line}${new_line}Choose one:${new_line}"
	
	msg_dnxhd_profile_encode_input_text="Choose a profile, depending of the media(s)'s characteristics ('$def_profile' by default).${new_line}"
	msg_prores_profile_encode_input_text="Choose a profile, depending of the media(s)'s characteristics ('$def_profile' by default).${new_line}${new_line}When in doubt, choose 'Auto'.${new_line}"
	msg_bitrate_encode_input_text="Enter a value for bitrate limit, $min_bitrate to $max_bitrate ($def_bitrate by default).${new_line}Lower equals better quality but bigger file.${new_line}${new_line}Tuning it may be necessary for videos with a lot of movement.${new_line}"
	msg_quality_encode_input_text="Choose a speed for compression ('${def_quality}' by default).${new_line}Slower equals better quality but slower encoding / decoding time.${new_line}"
	msg_gpu_encode_input_text="One or multiple compatible GPU(s) were detected.${new_line}Choose an encoding method ($def_encoder by default).${new_line}${new_line}GPU encoding may be faster depending of it's performance.${new_line}It will also free your computer for other tasks.${new_line}"
	msg_multithread_input_text="Do you want to run in multithread ?${new_line}${new_line}This will completly mobilise your CPU, accelerating${new_line}the encoding speed at the cost of your computer's reactivity.${new_line}${new_line}Recommended if you're not going to use it during operation.${new_line}"
	
	msg_codec_encode_input_text="Enter the desired codec:"
	msg_profile_encode_input_text="Enter the desired profile:"	

	msg_invalid_value="An invalid value was entered. Please, try again."

	msg_interpolate_multiplicator_input_text="Choose the number by which you want to${new_line}multiply the video(s)'s frame count (2 by default):"

	msg_rotate_title="Rotate file with angle of \"${value}\""
	msg_rotate_angle_input_text="Enter the desired rotation angle:"
	msg_rotate_finish_title="Rotation \"${name}\""

	### Localizables
	loc_lossless="Lossless"
	loc_lossy="Lossy"
}

load_language () {
	## Load localized strings AFTER english strings
	## - if localized strings not found use english for default
	## - if localized strings are incomplete use english only fot missing strings :-)
	load_language_en_US && [ "${lang}" != "en_US" ] && load_language_${lang}
}

lang=${LANG//.?*/}
type load_language_${lang} &> /dev/null || lang='en_US'
load_language

################################################################################

help () {
	echo "TODO"
	echo
	exit 0
}

######################################## Run Convert pro

run_reencode_dnxhd () {
##&& [ "${ext}" = ".mov" ];

	if [ "${overwrite}" = true ];  then
		sleep 0.8
		cp "${input}" "${dir}/${base}_TEMP.mov"
		rm "${input}"
		########### FFMPEG does not cache files being reencoded
		< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${dir}/${base}_TEMP.mov" -c:v "${vcodec}" -profile:v "${vprofile}"s -c:a copy "${input}" 2>&1)
		rm "${dir}/${base}_TEMP.mov"
	else
		sleep 0.8
		msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -c:v "${vcodec}" -profile:v "${vprofile}" -c:a copy "${dir}/${base}_converted.mov" 2>&1)
	fi
		
	return $?
}

run_reencode_prores () {
##&& [ "${ext}" = ".mov" ];

	if [ "${overwrite}" = true ];  then
		sleep 0.8
		cp "${input}" "${dir}/${base}_TEMP.mov"
		rm "${input}"
		########### FFMPEG does not cache files being reencoded
		< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${dir}/${base}_TEMP.mov" -c:v "${vcodec}"$opt_profile -c:a copy "${input}" 2>&1)
		rm "${dir}/${base}_TEMP.mov"
	else
		sleep 0.8
		msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -c:v "${vcodec}"${opt_profile} -c:a copy "${dir}/${base}_converted.mov" 2>&1)
	fi
		
	return $?
}

######################################## Run Convert

run_reencode_h264 () {
##&& [ "${ext}" = ".mov" ];

	if [ "${overwrite}" = true ];  then		
		sleep 0.8
		cp "${input}" "${dir}/${base}_TEMP.mov"
		rm "${input}"
		########### FFMPEG does not cache files being reencoded

		< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${dir}/${base}_TEMP.mov" -pix_fmt yuv420p -c:v "${vcodec}" -c:a copy${opt_bitrate} -preset "${vquality}" "${input}" 2>&1)	
		rm "${dir}/${base}_TEMP.mov"
	else
		sleep 0.8
		msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -pix_fmt yuv420p -c:v "${vcodec}" -c:a copy${opt_bitrate} -preset "${vquality}" "${dir}/${base}_converted.mp4" 2>&1)
	fi
		
	return $?
}

run_reencode_hevc () {
##&& [ "${ext}" = ".mov" ];

	if [ "${overwrite}" = true ];  then		
		sleep 0.8
		cp "${input}" "${dir}/${base}_TEMP.mp4"
		rm "${input}"
		########### FFMPEG does not cache files being reencoded

		< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${dir}/${base}_TEMP.mov" -pix_fmt yuv420p -c:v "${vcodec}" -c:a copy${opt_bitrate} -preset "${vquality}" "${input}" 2>&1)	
		rm "${dir}/${base}_TEMP.mp4"
	else
		sleep 0.8
		msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -pix_fmt yuv420p -c:v "${vcodec}" -c:a copy${opt_bitrate} -preset "${vquality}" "${dir}/${base}_converted.mp4" 2>&1)
	fi
		
	return $?
}

run_reencode_vp9 () {
##&& [ "${ext}" = ".mov" ];

	if [ "${vcodec}" = "libvpx-vp9" ];  then
		if [ "${overwrite}" = true ];  then		
			sleep 0.8
			cp "${input}" "${dir}/${base}_TEMP.mov"
			rm "${input}"
			########### FFMPEG does not cache files being reencoded

			< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -pass 1 -b:v 0 -pix_fmt yuv420p10le -c:v "${vcodec}" -c:a copy${opt_bitrate} -quality "${vquality}" -row-mt "${multithread}" -f null /dev/null && \ 2>&1)
			< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -pass 2 -b:v 0 -pix_fmt yuv420p10le -c:v "${vcodec}" -c:a copy${opt_bitrate} -quality "${vquality}" -row-mt "${multithread}" "${input}" 2>&1)
			rm "${dir}/${base}_TEMP.mov"
		else
			sleep 0.8
			msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -pass 1 -b:v 0 -pix_fmt yuv420p10le -cpu-used 4 -c:v "${vcodec}"${opt_bitrate} -quality "${vquality}" -row-mt "${multithread}" -an -f null /dev/null && \ 2>&1)
			msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -pass 2 -b:v 0 -pix_fmt yuv420p10le -cpu-used 4 -c:v "${vcodec}"${opt_bitrate} -quality "${vquality}" -row-mt "${multithread}" -c:a libopus "${dir}/${base}_converted.webm" 2>&1)
		fi
	elif [ "${vcodec}" = "vp9_qsv" ];  then
		if [ "${overwrite}" = true ];  then		
			sleep 0.8
			cp "${input}" "${dir}/${base}_TEMP.mov"
			rm "${input}"
			########### FFMPEG does not cache files being reencoded

			< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -c:v "${vcodec}" -preset "${vquality}" -c:a libopus "${input}" 2>&1)
			rm "${dir}/${base}_TEMP.mov"
		else
			sleep 0.8
			msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -c:v "${vcodec}" -preset "${vquality}" -c:a libopus "${dir}/${base}_converted.webm" 2>&1)
		fi
	fi

	return $?
}

######################################## Run Rewrap

run_rewrap () {
	if [ "${overwrite}" = true ] && [ "${ext}" = "${format}" ]; then
		sleep 0.8
		msg=$("${ffmpeg_bin}" -i "${input}" -c copy -map 0 "${input}.${format}" 2>&1)
	else
		sleep 0.8
		msg=$("${ffmpeg_bin}" -i "${input}" -c copy -map 0 "${dir}/${base}.${format}" 2>&1)
	fi

	return $?

}

######################################## Run Tools

run_horizontal_disassemble () {

	mkdir "${dir}/${base}_frames"
	msg=$("${ffmpeg_bin}" -i "${input}" "${dir}/${base}_frames/${base}_%03d.${value}" 2>&1)

	return $?
}

run_interpolate () {
	
	base="${base}"

	if [ "${value}" = "minterpolate" ]; then
	
		if [ "${overwrite}" = true ];  then
			fps=$(ffmpeg -i "${dir}/${base}.${ext}" 2>&1 | sed -n 's/.*, \(.*\) fp.*/\1/p')
			fps_multiplied=$((${fps} * ${multiplicator}))

			cp "${input}" "${dir}/${base}_TEMP.${ext}"
			rm "${input}"

			< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${dir}/${base}_TEMP.${ext}" -filter:v minterpolate -r "${fps_multiplied}" "${input}" 2>&1 )

			rm "${dir}/${base}_TEMP.${ext}"

		else
			fps=$(ffmpeg -i "${dir}/${base}.${ext}" 2>&1 | sed -n 's/.*, \(.*\) fp.*/\1/p')
			fps_multiplied=$((${fps} * ${multiplicator}))

			< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -filter:v minterpolate -r "${fps_multiplied}" "${dir}/${base}_interpolated.${ext}" 2>&1 )	
		fi

	else

		if [ "${overwrite}" = true ];  then
			fps=$(ffmpeg -i "${dir}/${base}.${ext}" 2>&1 | sed -n 's/.*, \(.*\) fp.*/\1/p')
			fps_multiplied=$((${fps} * ${multiplicator}))
			detect_vcodec=$(ffprobe -i "${dir}/${base}.${ext}" 2>&1 | grep -i Stream )
			detect_acodec=$(ffprobe -i "${dir}/${base}.${ext}" 2>&1 | grep -i Stream )

			if [[ ${detect_vcodec} = *"Video:"* ]]; then detect_video_codec; fi
			if [[ ${detect_acodec} = *"Audio:"* ]]; then detect_audio_codec; opt_audio=" -i "$dir/$base audio_TEMP.$aext" -c:a copy"; fi

			mkdir "${dir}/${base}_input_TEMP"
			mkdir "${dir}/${base}_output_TEMP"

			ffmpeg -i "${dir}/${base}.${ext}" -vn -acodec copy "${dir}/${base} audio_TEMP.${aext}"
			ffmpeg -i "${dir}/${base}.${ext}" "${dir}/${base}_input_TEMP/frame_%08d.png"

			cp "${input}" "${dir}/${base}_TEMP.${ext}"
			rm "${input}"

			"${value}" -i "${dir}/${base}_input_TEMP" -o "${dir}/${base}_output_TEMP"
			msg=$("${ffmpeg_bin}" -framerate "${fps_multiplied}" -i "${dir}/${base}_output_TEMP/%08d.png"$opt_audio$opt_video "${input}" 2>&1 )

			rm "${dir}/${base}_TEMP.${ext}"
			rm -r "${dir}/${base}_input_TEMP"
			rm -r "${dir}/${base}_output_TEMP"
			rm "${dir}/${base} audio_TEMP.${aext}"
		else
			fps=$(ffmpeg -i "${dir}/${base}.${ext}" 2>&1 | sed -n 's/.*, \(.*\) fp.*/\1/p')
			fps_multiplied=$((${fps} * ${multiplicator}))
			detect_vcodec=$(ffprobe -i "${dir}/${base}.${ext}" 2>&1 | grep -i Stream )
			detect_acodec=$(ffprobe -i "${dir}/${base}.${ext}" 2>&1 | grep -i Stream )

			if [[ ${detect_vcodec} = *"Video:"* ]]; then detect_video_codec; fi
			if [[ ${detect_acodec} = *"Audio:"* ]]; then detect_audio_codec; opt_audio=" -i "$dir/$base audio_TEMP.$aext" -c:a copy"; fi #opt_audio needs the double commas (syntax highlight may be weird)

			mkdir "${dir}/${base}_input_TEMP"
			mkdir "${dir}/${base}_output_TEMP"

			ffmpeg -i "${dir}/${base}.${ext}" -vn -acodec copy "${dir}/${base} audio_TEMP.${aext}"
			ffmpeg -i "${dir}/${base}.${ext}" "${dir}/${base}_input_TEMP/frame_%08d.png"

			"${value}" -i "${dir}/${base}_input_TEMP" -o "${dir}/${base}_output_TEMP"
			msg=$("${ffmpeg_bin}" -framerate "${fps_multiplied}" -i "${dir}/${base}_output_TEMP/%08d.png"$opt_audio$opt_video "${dir}/${base}_interpolated.${ext}" 2>&1 )

			rm -r "${dir}/${base}_input_TEMP"
			rm -r "${dir}/${base}_output_TEMP"
			rm "${dir}/${base} audio_TEMP.${aext}"
		fi

	fi
	return $?
}

######################################## Run adders / subtractors

run_add_music () {

msg=$("${ffmpeg_bin}" -i "${input}" -i "${add_input}" -filter_complex filter_complex "[0:v]trim=start=0[out0];[0:a]atrim=start=0[out1];[out1][1:a]sidechaingate=level_in=1:mode=downward:threshold=0.125:ratio=2:attack=20:release=250:makeup=1:knee=2.828427125:detection=rms[out2]" -map "[out0]" -map "[out2]" "${dir}/${base}_music_added.${ext}" 2>&1 )

msg=$("${ffmpeg_bin}" -i "${input}" -i "${add_input}" -filter_complex "[0:v]trim=start=0[out0];[0:a]atrim=start=0[out1];[out1][1:a]amix=inputs=2:duration=longest:dropout_transition=2:weights=1 1:normalize=1[out2]" -map "[out0]" -map "[out2]" "${dir}/${base}_music_added.${ext}" 2>&1 )

}

#run_add_watermark () {
#
#
#}

######################################## Run filters

run_sepia () {
	
	if [ "${overwrite}" = true ];  then
		cp "${input}" "${dir}/${base}_TEMP.${ext}"
		rm "${input}"

		msg=$("${ffmpeg_bin}" -i "${dir}/${base}_TEMP.${ext}" -filter_complex colorchannelmixer=.393:.769:.189:0:.349:.686:.168:0:.272:.534:.131 -c:a copy "${input}" 2>&1)

		rm "${dir}/${base}_TEMP.${ext}"
	else
		msg=$("${ffmpeg_bin}" -i "${input}" -filter_complex colorchannelmixer=.393:.769:.189:0:.349:.686:.168:0:.272:.534:.131 -c:a copy "${dir}/${base}_sepia.${ext}" 2>&1)
	fi

	return $?
}

run_gray () {
	
	if [ "${overwrite}" = true ];  then
		cp "${input}" "${dir}/${base}_TEMP.${ext}"
		rm "${input}"

		msg=$("${ffmpeg_bin}" -i "${dir}/${base}_TEMP.${ext}" -filter_complex colorchannelmixer=.393:.769:.189:0:.349:.686:.168:0:.272:.534:.131 -c:a copy "${input}" 2>&1)

		rm "${dir}/${base}_TEMP.${ext}"
	else
		msg=$("${ffmpeg_bin}" -i "${input}" -vf extractplanes=y -c:a copy "${dir}/${base}_gray.${ext}" 2>&1)
	fi

	return $?
}

######################################## Run Rotate

run_overturn () {
	if [ "${overwrite}" = true ];  then
		cp "${input}" "${dir}/${base}_TEMP.${ext}"
		rm "${input}"

		msg=$("${ffmpeg_bin}" -i "${dir}/${base}_TEMP.${ext}" -filter:v "${value}" -c:a copy "${input}" 2>&1)

		rm "${dir}/${base}_TEMP.${ext}"
	else
		msg=$("${ffmpeg_bin}" -i "${input}" -filter:v "${value}" -c:a copy "${dir}/${base}_rotated.${ext}" 2>&1)
	fi

	return $?
}

run_rotate () {
	if [ "${overwrite}" = true ];  then
		cp "${input}" "${dir}/${base}_TEMP.${ext}"
		rm "${input}"

		msg=$("${ffmpeg_bin}" -display_rotation "${angle}" -i "${dir}/${base}_TEMP.${ext}" -c:a copy "${input}" 2>&1)

		rm "${dir}/${base}_TEMP.${ext}"
	else
		msg=$("${ffmpeg_bin}" -display_rotation "${angle}" -i "${input}" -c:a copy "${dir}/${base}_rotated.${ext}" 2>&1)
	fi

	return $?
}


########################################

######################################## GPU detectors

detect_gpu_h264_hevc () {
	gpu_choice=$(lspci | grep -i '.* vga .*')

	if [[ "{$gpu_choice}" == *'UHD Graphics'* ]]; then
		gpu_list="${gpu_list}Intel "
		def_encoder="Intel"
	fi
	if [[ "{$gpu_choice}" == *'GeForce'* ]]; then
		gpu_list="${gpu_list}Nvidia "
		def_encoder="Nvidia"
	fi
	gpu_list="${gpu_list}CPU"
}

detect_gpu_interpolate () {
	gpu_choice=$(lspci | grep -i '.* vga .*')

	if [[ "{$gpu_choice}" == *'GeForce'* ]]; then
		gpu_list="${gpu_list}Nvidia "
		def_encoder="Nvidia"
	fi
	if [[ "{$gpu_choice}" == *'Radeon'* ]]; then
		gpu_list="${gpu_list}AMD "
		def_encoder="AMD"
	fi
	gpu_list="${gpu_list}CPU"
}

detect_gpu_vp9 () {
	gpu_choice=$(lspci | grep -i '.* vga .*')

	if [[ "{$gpu_choice}" == *'UHD Graphics'* ]]; then
		gpu_list="${gpu_list}Intel "
		def_encoder="Intel"
	fi
	gpu_list="${gpu_list}CPU"
}

######################################## Video / Audio codec detector (Used for AIs who need to dissasemble the videos)

detect_video_codec () {

	def_vfallback=$loc_lossless

	vfallback_list=("$loc_lossless $loc_lossy")

	## Prores
	if [[ ${detect_vcodec} = *"prores"* ]]; then
	vcodec="prores"
	opt_video=" -c:v $vcodec"
		if [[ ${detect_vcodec} = *"(Proxy)"* ]]; then
		vprofile=0
		opt_video=" -c:v $vcodec -profile:v $vprofile"
		elif [[ ${detect_vcodec} = *"(LT)"* ]]; then
		vprofile=1
		opt_video=" -c:v $vcodec -profile:v $vprofile"
		elif [[ ${detect_vcodec} = *"(Standard)"* ]]; then
		vprofile=2
		opt_video=" -c:v $vcodec -profile:v $vprofile"
		elif [[ ${detect_vcodec} = *"(HQ)"* ]]; then
		vprofile=3
		opt_video=" -c:v $vcodec -profile:v $vprofile"
		elif [[ ${detect_vcodec} = *"(4444)"* ]]; then
		vprofile=4
		opt_video=" -c:v $vcodec -profile:v $vprofile"
		elif [[ ${detect_vcodec} = *"(XQ)"* ]]; then
		vprofile=5
		opt_video=" -c:v $vcodec -profile:v $vprofile"
		fi

	## DNXHD
	elif [[ ${detect_vcodec} = *"dnxhd"* ]]; then
	opt_video=" -c:v $vcodec -profile:v $vprofile"
		if [[ ${detect_vcodec} = *"(DNXHR LB)"* ]]; then
		vcodec="dnxhr_lb"
		elif [[ ${detect_vcodec} = *"(DNXHR SQ)"* ]]; then
		vcodec="dnxhr_sq"
		elif [[ ${detect_vcodec} = *"(DNXHR HQ)"* ]]; then
		vcodec="dnxhr_hq"
		elif [[ ${detect_vcodec} = *"(DNXHR HQX)"* ]]; then
		vcodec="dnxhr_hqx"
		elif [[ ${detect_vcodec} = *"(DNXHR 444)"* ]]; then
		vcodec="dnxhr_444"
		fi

	## H264
	elif [[ ${detect_vcodec} = *"h264"* ]]; then
	vcodec="libx264"; vbitrate=20; vquality=normal
	opt_video=" -c:v $vcodec -crf $vbitrate -preset $vquality"
		
		if [[ ${detect_vcodec} = *"h264"* ]] && [ def_encoder="Nvidia" ]; then
		vcodec="h264_nvenc"; vquality=p4
		opt_video=" -c:v $vcodec -preset $vquality"
		
		elif [[ ${detect_vcodec} = *"h264"* ]] && [ def_encoder="Intel" ]; then
		vcodec="h264_qsv"; vquality=slow
		opt_video=" -c:v $vcodec -preset $vquality"
		fi

	## NVENC
	elif [[ ${detect_vcodec} = *"nvenc"* ]]; then
	vcodec="libx265"; vbitrate=23; vquality=normal
	opt_video=" -c:v $vcodec -crf $vbitrate -preset $vquality"
		
		if [[ ${detect_vcodec} = *"nvenc"* ]] && [ def_encoder="Nvidia" ]; then
		vcodec="hevc_nvenc"; vquality=p4
		opt_video=" -c:v $vcodec -preset $vquality"
		fi

	## VP9
	elif [[ ${detect_vcodec} = *"vp9"* ]]; then
	vcodec="libvpx_vp9"; vbitrate=27; vquality=good
	opt_video=" -c:v $vcodec -crf $vbitrate -preset $vquality"
		if [[ ${detect_vcodec} = *"vp9"* ]] && [ def_encoder="Intel" ]; then
		vcodec="vp9_qsv"; vquality=medium
		opt_video=" -c:v $vcodec -preset $vquality"
		fi

	else 
		load_language

		vcodec=""; vprofile=""; vquality=""; vbitrate=""

		vfallback=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --combobox "${msg_vfallback_encode_input_text}" $vfallback_list) || \
			{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
		if [ "${fallback}" = "" ]; then fallback="${def_vfallback}" 
		fi
		
		if [ $vfallback=$loc_lossless ]; then
			if [ "${overwrite}"=true ]; then
				sleep 0.8
				cp "${input}" "${dir}/${base}_TEMP.${ext}"
				rm "${input}"
				########### FFMPEG does not cache files being reencoded

				< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -c:v prores -c:a copy "${input}" 2>&1)
				rm "${dir}/${base}_TEMP.${ext}"
			
			else
				msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -c:v prores -c:a copy "${dir}/${base}_converted.${ext}" 2>&1)
				base="${base}_converted"
			fi
		elif [ $vfallback=$loc_lossy ]; then
			if [ "${overwrite}"=true ]; then
				sleep 0.8
				cp "${input}" "${dir}/${base}_TEMP.${ext}"
				rm "${input}"
				########### FFMPEG does not cache files being reencoded

				< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${dir}/${base}_TEMP.${ext}" -c:v prores -c:a copy "${input}" 2>&1)
				rm "${dir}/${base}_TEMP.${ext}"
			else
				if [ detect_vcodec = *"h264"* ] && [ def_encoder="Nvidia" ]; then
				vcodec="h264_nvenc"; vquality=p4
				opt_video=" -c:v $vcodec -crf $vbitrate -preset $vquality"
				elif [ detect_vcodec = *"h264"* ] && [ def_encoder="Intel" ]; then
				vcodec="h264_qsv"; vquality=slow
				else
				vcodec="libx264"; vbitrate=23; vquality=normal
				opt_video=" -c:v $vcodec -crf $vbitrate -preset $vquality"
				fi
			msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -c:v "${vcodec}" -c:a copy "${dir}/${base}_converted.${ext}" 2>&1)
			base="${base}_converted"
				
			fi
		fi

	fi
}

detect_audio_codec () {

	def_afallback=${loc_lossless}

	afallback_list=("$loc_lossless $loc_lossy")

	## PCM
	if [[ ${detect_acodec} = *"pcm"* ]]; then
	profile=ffprobe -i "${dir}/${base}.${ext}" 2>&1 | grep -o -P '(?<=pcm_).*?(?= \()'
	acodec="pcm_$profile"; aext="waw"

	## AAC
	elif [[ ${detect_acodec} = *"aac"* ]]; then
	acodec="aac"; aext="m4a"

	## Opus
	elif [[ ${detect_acodec} = *"opus"* ]]; then
	acodec="opus"; aext="ogg"

	## Alac
	elif [[ ${detect_acodec} = *"alac"* ]]; then
	acodec="alac"; aext="mp3"

	## Flac
	elif [[ ${detect_acodec} = *"flac"* ]]; then
	acodec="flac"; aext="flac"

	else
		load_language

		acodec=""; aext=""

		afallback=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --combobox "${msg_afallback_encode_input_text}" $afallback_list) || \
			{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
		if [ "${afallback}" = "" ]; then afallback="${def_afallback}" 
		fi
		
		if [ "${afallback}" = "${loc_lossless}" ]; then
			acodec="pcm"; aext="waw"
			if [ "${overwrite}"=true ]; then
				printf "WRITE_LOSSLESS"
				sleep 0.8
				cp "${input}" "${dir}/${base}_TEMP.${ext}"
				rm "${input}"
				########### FFMPEG does not cache files being reencoded

				< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${dir}/${base}_TEMP.${ext}" -c:v copy -c:a pcm_s16le "${input}" 2>&1)
				rm "${dir}/${base}_TEMP.${ext}"
			
			else
				msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -c:v copy -c:a pcm_s16le "${dir}/${base}_converted.${ext}" 2>&1)
				base="${base}_converted"
			fi
		elif [ "${afallback}" = "${loc_lossy}" ]; then
			acodec="opus"; aext="ogg"
			if [ "${overwrite}"=true ]; then
				cp "${input}" "${dir}/${base}_TEMP.${ext}"
				rm "${input}"
				########### FFMPEG does not cache files being reencoded

				< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${dir}/${base}_TEMP.${ext}" -c:v copy -c:a libopus "${input}" 2>&1)
				rm "${dir}/${base}_TEMP.${ext}"
			else
				msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -c:v copy -c:a libopus "${dir}/${base}_converted.${ext}" 2>&1)
				base="${base}_converted"
			fi
		fi

	fi
}

do_you_want_to_overwrite () {
	"${kdialog_bin}" --icon configure --title "${!msg_title}" --warningyesno "${msg_common_overwrite_text}" && overwrite=true || \
		{
			[ $? -eq 1 ] && overwrite=false || \
				{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
		}
}

manage_input_separately () {
	[ ${#} -lt 1 ] && help
	[ ${#} -gt 1 ] && multiple_files=true

    # update messages with presently available vars
    load_language

	type run_${action} > /dev/null || \
		{ "${kdialog_bin}" --title "${msg_common_software_not_found_title}" --icon configure --error "${msg_common_action_not_found_text}" && exit 2; }

	[ "${ask_overwrite}" = true ] && do_you_want_to_overwrite

	quantity=$#
	dbus_ref=$(kdialog --icon configure --title "${!msg_title}" --progressbar "${msg_common_start}" $quantity)
	processed=0

	for input in "$@"; do
		## Check if window has been closed w. cancel / alt + f4...
		if [ "$?" = 0 ]; then
			dir=$(dirname -- "${input}")
			name="${input##*/}"
			base="${name%.*}"
			ext="${name##*.}"

			processed=$(($processed + 1))
			load_language			
			[ ! -f "${input}" ] && "${kdialog_bin}" --title --icon configure "${!msg_title}" --error "${msg_common_file_not_found}" && break
			qdbus $dbus_ref setLabelText "${msg_common_progress_text}"

			msg_finish_title=msg_${action}_finish_title
			run_${action} && \				
				"${kdialog_bin}" --title "${!msg_finish_title}" --passivepopup "${msg_common_finish_ok}" 5 || \
				{ qdbus $dbus_ref close; "${kdialog_bin}" --icon configure --title "${!msg_finish_title}" --detailederror "${msg_common_finish_error}" "${msg}"; exit 2; }
			
			qdbus $dbus_ref org.freedesktop.DBus.Properties.Set org.kde.kdialog.ProgressDialog value $processed
		else	
			"${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2;
		fi
	done

	qdbus $dbus_ref close
}

manage_input_at_once () {
	[ ${#} -lt 1 ] && help

	dir=$(dirname -- "${1}")
	name="${1##*/}"
	load_language

	msg_finish_title=msg_${action}_finish_title
	run_${action} "${@}" && \
		"${kdialog_bin}" --title "${!msg_finish_title}" --passivepopup "${msg_common_finish_ok}" 5 || \
		{ qdbus $dbus_ref close; "${kdialog_bin}" --icon configure --title "${!msg_finish_title}" --detailederror "${msg_common_finish_error}" "${msg}"; exit 2; }

}

######################################## Set convert video

set_reencode_dnxhd () {
	
	value="${1}"
	vcodec="${value}"
	shift

	############### Default values depending of the protocol

	def_profile="DNxHR(HQ)"
	profile_list=("DNxHR(LB) DNxHR(SQ) DNxHR(HQ) DNxHR(HQX) DNxHR(444)")

	############### Ask for tweaking depending of the protocol

	load_language

	profile=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --combobox "${msg_dnxhd_profile_encode_input_text}" $profile_list) || \
		{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
	if [ "${profile}" = "" ]; then profile="${def_profile}" 
	fi

	if [ "${profile}" = "DNxHR(LB)" ]; then
		vprofile="dnxhr_lb"
	elif [ "${profile}" = "DNxHR(SQ)" ]; then
		vprofile="dnxhr_sq"
	elif [ "${profile}" = "DNxHR(HQ)" ]; then
		vprofile="dnxhr_hq"
	elif [ "${profile}" = "DNxHR(HQX)" ]; then
		vprofile="dnxhr_hqx"
	elif [ "${profile}" = "DNxHR(444)" ]; then
		vprofile="dnxhr_444"
	fi
	
	ask_overwrite=true

	manage_input_separately "${@}"
}


set_reencode_prores () {
	
	value="${1}"
	vcodec="${value}"
	shift

	############### Default values depending of the protocol

	def_profile=Auto
	profile_list=("Auto 422(Proxy) 422(LT) 422(Standard) 422(HQ) 4444 4444(XQ)")

	############### Ask for tweaking depending of the protocol

	load_language

	profile=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --combobox "${msg_prores_profile_encode_input_text}" $profile_list) || \
		{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
	if [ "${profile}" = "" ]; then profile="${def_profile}" 
	fi

	if [ "${profile}" = "422(Proxy)" ]; then
		vprofile="0"
	elif [ "${profile}" = "422(LT)" ]; then
		vprofile="1"
	elif [ "${profile}" = "422(Standard)" ]; then
		vprofile="2"
	elif [ "${profile}" = "422(HQ)" ]; then
		vprofile="3"
	elif [ "${profile}" = "4444" ]; then
		vprofile="4"
	elif [ "${profile}" = "4444(XQ)" ]; then
		vprofile="5"
	fi

	if [ "${profile}" != "Auto" ]; then
		opt_profile=" -profile:v $vprofile"
	fi
	
	ask_overwrite=true

	manage_input_separately "${@}"
}

set_reencode_h264 () {
	
	value="${1}"
	vcodec="${value}"
	shift

	
	############### Detect compatible GPU and choose which encode protocol is used. Important values are decided fron this function

	detect_gpu_h264_hevc
	load_language

	if [ "${gpu_list}" != "CPU" ]; then
		encoder=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --combobox "${msg_gpu_encode_input_text}" $gpu_list) || \
			{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
		if [ "${encoder}" = "" ]; then encoder="${def_encoder}"
		fi
	
		if [ "${encoder}" = "Intel" ]; then
			vcodec="h264_qsv"
		elif [ "${encoder}" = "Nvidia" ]; then
			vcodec="h264_nvenc"
		elif [ "${encoder}" = "CPU" ]; then
			vcodec="libx264"
		fi
	fi

	############### Default values depending of the protocol

	if [ "${vcodec}" = "h264_qsv" ]; then
		def_quality=medium
		quality_list=("veryfast faster fast medium slow slower veryslow")
	elif [ "${vcodec}" = "h264_nvenc" ]; then
		def_quality=p4
		quality_list=("p1 p2 p3 p4 p5 p6 p7")
	elif [ "${vcodec}" = "libx264" ]; then
		def_bitrate=23; def_quality=medium;
		quality_list=("ultrafast superfast veryfast faster fast medium slow slower veryslow")
	fi
	
	############### Ask for tweaking depending of the protocol

	valid_value="false"

	min_bitrate=0; max_bitrate=51;
	load_language

	if [ "${vcodec}" = "libx264" ]; then

		while [ "${valid_value}" = "false" ]; do
			vbitrate=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --inputbox "${msg_bitrate_encode_input_text}" $def_bitrate) || \
				{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }

			valid_value="true"

			if [[ ! $bitrate =~ ^[0-9]+$ ]] || [ $bitrate -lt $min_bitrate ] || [ $bitrate -gt $max_bitrate ]; then
				"${kdialog_bin}" --title --icon configure "${!msg_title}" --error "${msg_invalid_value}"
				valid_value="false"
			fi
		done
	
	opt_bitrate=" -crf $vbitrate"
	fi
	
	vquality=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --combobox "${msg_quality_encode_input_text}" $quality_list) || \
		{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
	if [ "${vquality}" = "" ]; then vquality="${def_quality}" 
	fi

	ask_overwrite=true
	
	manage_input_separately "${@}"
}

set_reencode_hevc () {
	
	shift
	value="${1}"
	vcodec="${value}"

	############### Detect compatible GPU and choose which encode protocol is used. Important values are decided fron this function

	detect_gpu_h264_hevc
	load_language
	
	if [ "${gpu_list}" != "CPU" ]; then
		encoder=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --combobox "${msg_gpu_encode_input_text}" $gpu_list) || \
			{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
		if [ "${encoder}" = "" ]; then encoder="${def_encoder}"
		fi
	
		if [ "${encoder}" = "Intel" ]; then
			vcodec="hevc_qsv"
		elif [ "${encoder}" = "Nvidia" ]; then
			vcodec="hevc_nvenc"
		elif [ "${encoder}" = "CPU" ]; then
			vcodec="libx265"
		fi
	fi

	############### Default values depending of the protocol

	if [ "${vcodec}" = "hevc_qsv" ]; then
		def_quality=medium
		quality_list=("veryfast faster fast medium slow slower veryslow")
	elif [ "${vcodec}" = "hevc_nvenc" ]; then
		def_quality=p4
		quality_list=("p1 p2 p3 p4 p5 p6 p7")
	elif [ "${vcodec}" = "libx265" ]; then
		def_bitrate=28; def_quality=medium;
		quality_list=("ultrafast superfast veryfast faster fast medium slow slower veryslow")
	fi
	
	############### Ask for tweaking depending of the protocol

	valid_value="false"

	min_bitrate=0; max_bitrate=51;
	load_language

	if [ "${vcodec}" = "libx265" ]; then

		while [ "${valid_value}" = "false" ]; do
			bitrate=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --inputbox "${msg_bitrate_encode_input_text}" $def_bitrate) || \
				{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }

			valid_value="true"

			if [[ ! $bitrate =~ ^[0-9]+$ ]] || [ $bitrate -lt $min_bitrate ] || [ $bitrate -gt $max_bitrate ]; then
				"${kdialog_bin}" --title --icon configure "${!msg_title}" --error "${msg_invalid_value}"
				valid_value="false"
			fi
		done
	
	opt_bitrate=" -crf $bitrate"
	fi
	
	vquality=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --combobox "${msg_quality_encode_input_text}" $quality_list) || \
		{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
	if [ "${vquality}" = "" ]; then vquality="${def_quality}" 
	fi

	ask_overwrite=true

	manage_input_separately "${@}"
}

set_reencode_vp9 () {

	shift
	value="${1}"
	vcodec="${value}"
	

	############### Detect compatible GPU and choose which encode protocol is used. Important values are decided fron this function

	detect_gpu_vp9
	load_language
	
	if [ "${gpu_list}" != "CPU" ]; then
		encoder=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --combobox "${msg_gpu_encode_input_text}" $gpu_list) || \
			{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
		if [ "${encoder}" = "" ]; then encoder="${def_encoder}"
		fi
	
		if [ "${encoder}" = "Intel" ]; then
			vcodec="vp9_qsv"
		elif [ "${encoder}" = "CPU" ]; then
			vcodec="libvpx-vp9"
		fi
	fi

	############### Default values depending of the protocol

	if [ "${vcodec}" = "vp9_qsv" ]; then
		def_quality=medium; multithread=0;
		quality_list=("veryfast faster fast medium slow slower veryslow")
	elif [ "${vcodec}" = "libvpx-vp9" ]; then
		def_bitrate=31; def_quality=good; multithread=0;
		quality_list=("best good realtime")
	fi

	############### Ask for tweaking depending of the protocol

	valid_value="false"

	min_bitrate=0; max_bitrate=63;
	load_language

	if [ "${vcodec}" = "libvpx-vp9" ]; then
		while [ "${valid_value}" = "false" ]; do
			bitrate=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --inputbox "${msg_bitrate_encode_input_text}" $def_bitrate) || \
				{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }

			valid_value="true"

			if [[ ! $bitrate =~ ^[0-9]+$ ]] || [ $bitrate -lt $min_bitrate ] || [ $bitrate -gt $max_bitrate ]; then
				"${kdialog_bin}" --title --icon configure "${!msg_title}" --error "${msg_invalid_value}"
				valid_value="false"
			fi
		done
	
	opt_bitrate=" -crf $bitrate"
	fi

	vquality=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --combobox "${msg_quality_encode_input_text}" $quality_list) || \
		{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
	if [ "${vquality}" = "" ]; then vquality="${def_quality}"
	fi

	if [ "${vcodec}" = "libvpx-vp9" ]; then	
		"${kdialog_bin}" --icon configure --title "${!msg_title}" --yesno "${msg_multithread_input_text}" && multithread=1 || \
			{ [ $? -eq 1 ] && multithread=0 || \
					{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
			}
	fi

	ask_overwrite=true

	manage_input_separately "${@}"
}

set_rewrap () {
	value="${1}"
	shift

	if [ "${value}" = "custom" ]; then
		format=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --inputbox "${msg_rewrap_format_input_text}") || \
			{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
	else
		format="${value}"
	fi

	for arg in "$@"; do
		arg_ext="${arg##*.}"
		[ "${arg_ext}" = "${format}" ] && ask_overwrite=true && break
	done

	manage_input_separately "${@}"
}

set_interpolate () {
	value="${1}"
	shift
	############### Default values depending of the protocol
	def_multi=2
	def_model=RIFE
	multiplicator_list=("2 4 6 8")
	model_list=("$rife_list $dain_list Minterpolate")

	detect_gpu_interpolate

	load_language

	if [ "${gpu_list}" != "CPU" ] && [ ! -z "${rife_bin}" ]; then
		model=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --combobox "${msg_gpu_interpolate_input_text}" $model_list) || \
			{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
		if [ "${model}" = "" ]; then model="${def_model}" 
		fi

		if [ "${model}" = "RIFE" ]; then
			value="${rife_bin}"
		elif [ "${model}" = "DAIN" ]; then
			value="${dain_bin}"
		elif [ "${model}" = "Minterpolate" ]; then
			value="minterpolate"
		fi
	fi

	multiplicator=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --combobox "${msg_interpolate_multiplicator_input_text}" ${multiplicator_list} ) || \
		{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
	if [ "${multiplicator}" = "" ]; then multiplicator="${def_multi}" 
	fi

	ask_overwrite=true

	manage_input_separately "${@}"
}

set_overturn () {
	value="${1}"
	shift

	for arg in "$@"; do
		arg_ext="${arg##*.}"
		[ "${arg_ext}" = "${format}" ] && ask_overwrite=true && break
	done

	manage_input_separately "${@}"
}

######################################## Run adders / subtractors

set_add_music () {

	add_input=$("${kdialog_bin}" --title "${!msg_title}" --icon document-open --getopenfilename " " ) || \
		{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }

	add_input_name="${add_input##*/}"
	add_input_base="${add_input%.*}"

	manage_input_separately "${@}"
}

#set_add_watermark () {
#
#}

######################################## Run filters


set_sepia () {
	for arg in "$@"; do
		arg_ext="${arg##*.}"
		[ "${arg_ext}" = "${format}" ] && ask_overwrite=true && break
	done

	manage_input_separately "${@}"
}

set_gray () {
	for arg in "$@"; do
		arg_ext="${arg##*.}"
		[ "${arg_ext}" = "${format}" ] && ask_overwrite=true && break
	done

	manage_input_separately "${@}"
}

##################################################### Run Rotate

set_rotate () {
	value="${1}"
	shift

	if [ "${value}" = "custom" ]; then
		angle=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --inputbox "${msg_rotate_angle_input_text}") || \
			{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
	else
		angle="${value}"
	fi

	for arg in "$@"; do
		arg_ext="${arg##*.}"
		[ "${arg_ext}" = "${format}" ] && ask_overwrite=true && break
	done

	manage_input_separately "${@}"
}

set_horizontal_disassemble () {
	value="${1}"
	shift

	manage_input_separately "${@}"
}


################################################################################

[ "${1}" = "-h" ] || [ "${1}" = "--help" ] || [ ${#} -lt 2 ] && help

########################### Mandatory

kdialog_bin=$(which kdialog)
[ -z "${kdialog_bin}" ] && echo "kdialog not found!" && exit 1

ffmpeg_bin=$(which ffmpeg)
[ -z "${ffmpeg_bin}" ] && \
	"${kdialog_bin}" --icon configure --title "${msg_common_software_not_found_title}" --error "${msg_common_ffmpeg_not_found_text}" && exit 2

########################### Optional

rife_bin=$(which /usr/share/rife-ncnn-vulkan/rife-ncnn-vulkan)
[ ! -z "${rife_bin}" ] && rife_list="RIFE"

dain_bin=$(which /usr/share/dain-ncnn-vulkan/dain-ncnn-vulkan)
[ ! -z "${dain_bin}" ] && dain_list="DAIN"
	

action="${1}"
shift



load_language
msg_title=msg_${action}_title
msg_finish_title=msg_${action}_finish_title

type set_${action} &> /dev/null || \
	{ "${kdialog_bin}" --icon configure --title "${msg_common_software_not_found_title}" --error "${msg_common_action_not_found_text}" && exit 3; }

ask_overwrite=false
set_${action} "${@}"

exit 0
