#! /bin/bash
#
# 	Part of kde-service-menu-revideo Version 0.1.1
# 	Copyright (C) 2018-2019 Giuseppe Benigno <giuseppe.benigno(at)gmail.com>
# 	Copyright (C) 2024 <fashim99.(at)gmail.com>
#
# 	This program is free software: you can redistribute it and/or modify
# 	it under the terms of the GNU General Public License as published by
# 	the Free Software Foundation, either version 3 of the License, or
# 	(at your option) any later version.
#
# 	This program is distributed in the hope that it will be useful,
# 	but WITHOUT ANY WARRANTY; without even the implied warranty of
# 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# 	GNU General Public License for more details.
#
# 	You should have received a copy of the GNU General Public License
# 	along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

#### languages strings messages #################
# Syntax for strings name is: msg_[$format]_$window_[$section]
# For languages as sr@Latn use srLatn

new_line="
"

load_language_en_US () {
	msg_common_software_not_found_title="Software not found"
	msg_common_ffmpeg_not_found_text="Software Ffmpeg not found! Please, install it."
	msg_common_action_not_found_text="The requested action is not implemented."
	msg_common_overwrite_text="In case the images to be saved have the same name as those to be processed,${new_line}do you want to overwrite them?"
	msg_common_abort="Operation interrupted by the user."
	msg_common_file_not_found="File \"${name}\" not found!"
	msg_common_name_error="The file name \"${name}\" does not match a recognized format for a date.${new_line}${new_line}The name must be of the type: YYYY-MM-DD_HHMMSS.jpg"
	msg_common_start="Initialising ... "
	msg_common_progress_text="Processing file $processed of $quantity ($(basename "${input}"))"
	msg_common_finish_ok="Done."
	msg_common_finish_error="An error has occurred."
	msg_common_transparent_unsupported_text="This codec format does not support transparency.${new_line}Convert to an alpha codec."
# 	msg_common_details="Details:"

	msg_compress_title="Image compression with quality \"${value}\""
	msg_compress_quality_input_text="Type the quality:"
	msg_compress_finish_title="Compression of \"${name}\""

	msg_bitrate_encode_input_text="Enter a value for bitrate limit, $min_bitrate to $max_bitrate ($def_bitrate by default).${new_line}Lower equals better quality but bigger file.${new_line}${new_line}Tuning it may be necessary for videos with a lot of movement.${new_line}"
	msg_quality_encode_input_text="Choose a speed for compression ('${def_quality}' by default).${new_line}Slower equals better quality but slower encoding / decoding time.${new_line}"
	msg_gpu_encode_input_text="One or multiple compatible GPU(s) were detected.${new_line}Choose an encoding method ($def_encoder by default).${new_line}${new_line}GPU encoding may be faster depending of it's performance.${new_line}It will also free your computer for other tasks.${new_line}"
	msg_multithread_input_text="Do you want to run in multithread ?${new_line}${new_line}This will completly mobilise your CPU, accelerating${new_line}the encoding speed at the cost of your computer's reactivity.${new_line}${new_line}Recommended if you're not going to use it during operation.${new_line}"
	
	msg_codec_encode_input_text="Enter the desired codec:"
	msg_profile_encode_input_text="Enter the desired profile:"	

	msg_invalid_value="An invalid value was entered. Please, try again."

	msg_interpolate_multiplicator_input_text="Choose the number by which you want to${new_line}multiply the video(s)'s frame count (2 by default):"

	msg_rotate_title="Rotate file with angle of \"${value}\""
	msg_rotate_angle_input_text="Enter the desired rotation angle:"
	msg_rotate_finish_title="Rotation \"${name}\""

}

load_language () {
	## Load localized strings AFTER english strings
	## - if localized strings not found use english for default
	## - if localized strings are incomplete use english only fot missing strings :-)
	load_language_en_US && [ "${lang}" != "en_US" ] && load_language_${lang}
}

lang=${LANG//.?*/}
type load_language_${lang} &> /dev/null || lang='en_US'
load_language

################################################################################

help () {
	echo "TODO"
	echo
	exit 0
}

######################################## Run Convert pro

run_reencode_pro () {
##&& [ "${ext}" = ".mov" ];

	if [ "${auto}" = "auto" ];  then

		if [ "${overwrite}" = true ];  then
			sleep 0.8
			cp "${input}" "${dir}/${base}_TEMP.mov"
			rm "${input}"
			########### FFMPEG does not cache files being reencoded

			< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${dir}/${base}_TEMP.mov" -c:v "${vcodec}" -c:a copy "${input}" 2>&1)
			rm "${dir}/${base}_TEMP.mov"
		else
			sleep 0.8
			msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -c:v "${vcodec}" -c:a copy "${dir}/${base}_converted.mov" 2>&1)
		fi

	else

		if [ "${overwrite}" = true ];  then
			cp "${input}" "${dir}/${base}_TEMP.mov"
			rm "${input}"
			########### FFMPEG does not cache files being reencoded

			< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${dir}/${base}_TEMP.mov" -c:v "${vcodec}" -profile:v "${profile}" -c:a copy "${input}" 2>&1)
			rm "${dir}/${base}_TEMP.mov"
		else
			sleep 0.8
			msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -c:v "${vcodec}" -profile:v "${profile}" -c:a copy "${dir}/${base}_converted.mov" 2>&1)
		fi

	fi
		
	return $?
}

######################################## Run Convert

run_reencode_h264 () {
##&& [ "${ext}" = ".mov" ];

	if [ "${overwrite}" = true ];  then		
		sleep 0.8
		cp "${input}" "${dir}/${base}_TEMP.mov"
		rm "${input}"
		########### FFMPEG does not cache files being reencoded

		< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${dir}/${base}_TEMP.mov" -pix_fmt yuv420p -c:v "${vcodec}" -c:a copy${opt_bitrate} -preset "${quality}" "${input}" 2>&1)	
		rm "${dir}/${base}_TEMP.mov"
	else
		sleep 0.8
		msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -pix_fmt yuv420p -c:v "${vcodec}" -c:a copy${opt_bitrate} -preset "${quality}" "${dir}/${base}_converted.mp4" 2>&1)
	fi
		
	return $?
}

run_reencode_hevc () {
##&& [ "${ext}" = ".mov" ];

	if [ "${overwrite}" = true ];  then		
		sleep 0.8
		cp "${input}" "${dir}/${base}_TEMP.mov"
		rm "${input}"
		########### FFMPEG does not cache files being reencoded

		< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${dir}/${base}_TEMP.mov" -pix_fmt yuv420p -c:v "${vcodec}" -c:a copy${opt_bitrate} -preset "${quality}" "${input}" 2>&1)	
		rm "${dir}/${base}_TEMP.mov"
	else
		sleep 0.8
		msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -pix_fmt yuv420p -c:v "${vcodec}" -c:a copy${opt_bitrate} -preset "${quality}" "${dir}/${base}_converted.mp4" 2>&1)
	fi
		
	return $?
}

run_reencode_vp9 () {
##&& [ "${ext}" = ".mov" ];

	if [ "${vcodec}" = "libvpx-vp9" ];  then
		if [ "${overwrite}" = true ];  then		
			sleep 0.8
			cp "${input}" "${dir}/${base}_TEMP.mov"
			rm "${input}"
			########### FFMPEG does not cache files being reencoded

			< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -pass 1 -b:v 0 -pix_fmt yuv420p10le -c:v "${vcodec}" -c:a copy${opt_bitrate} -quality "${quality}" -row-mt "${multithread}" -f null /dev/null && \ 2>&1)
			< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -pass 2 -b:v 0 -pix_fmt yuv420p10le -c:v "${vcodec}" -c:a copy${opt_bitrate} -quality "${quality}" -row-mt "${multithread}" "${input}" 2>&1)
			rm "${dir}/${base}_TEMP.mov"
		else
			sleep 0.8
			msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -pass 1 -b:v 0 -pix_fmt yuv420p10le -cpu-used 4 -c:v "${vcodec}"${opt_bitrate} -quality "${quality}" -row-mt "${multithread}" -an -f null /dev/null && \ 2>&1)
			msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -pass 2 -b:v 0 -pix_fmt yuv420p10le -cpu-used 4 -c:v "${vcodec}"${opt_bitrate} -quality "${quality}" -row-mt "${multithread}" -c:a libopus "${dir}/${base}_converted.webm" 2>&1)
		fi
	elif [ "${vcodec}" = "vp9_qsv" ];  then
		if [ "${overwrite}" = true ];  then		
			sleep 0.8
			cp "${input}" "${dir}/${base}_TEMP.mov"
			rm "${input}"
			########### FFMPEG does not cache files being reencoded

			< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -c:v "${vcodec}" -preset "${quality}" -c:a libopus "${input}" 2>&1)
			rm "${dir}/${base}_TEMP.mov"
		else
			sleep 0.8
			msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -c:v "${vcodec}" -preset "${quality}" -c:a libopus "${dir}/${base}_converted.webm" 2>&1)
		fi
	fi

	return $?
}

######################################## Run Rewrap

run_rewrap () {
	if [ "${overwrite}" = true ] && [ "${ext}" = "${format}" ]; then
		sleep 0.8
		msg=$("${ffmpeg_bin}" -i "${input}" -c copy -map 0 "${input}.${format}" 2>&1)
	else
		sleep 0.8
		msg=$("${ffmpeg_bin}" -i "${input}" -c copy -map 0 "${dir}/${base}.${format}" 2>&1)
	fi

	return $?

}

######################################## Run Tools

run_horizontal_disassemble () {

	mkdir "${dir}/${base}_frames"
	msg=$("${ffmpeg_bin}" -i "${input}" "${dir}/${base}_frames/${base}_%03d.${value}" 2>&1)

	return $?
}

run_interpolate () {
	if [ "${overwrite}" = true ];  then
		fps=$(ffmpeg -i "${dir}/${base}.${ext}" 2>&1 | sed -n 's/.*, \(.*\) fp.*/\1/p')
		fps_multiplied=$((${fps} * ${multiplicator}))

		cp "${input}" "${dir}/${base}_TEMP.${ext}"
		rm "${input}"

		< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${dir}/${base}_TEMP.${ext}" -filter:v minterpolate -r "${fps_multiplied}" "${input}" 2>&1)

		rm "${dir}/${base}_TEMP.${ext}"
	else
		fps=$(ffmpeg -i "${dir}/${base}.${ext}" 2>&1 | sed -n 's/.*, \(.*\) fp.*/\1/p')
		fps_multiplied=$((${fps} * ${multiplicator}))

		< /dev/null msg=$("${ffmpeg_bin}" -nostdin -i "${input}" -filter:v minterpolate -r "${fps_multiplied}" "${dir}/${base}_interpolated.${ext}" 2>&1)	
	fi

	return $?
}

######################################## Run Rotate

run_overturn () {
	if [ "${overwrite}" = true ];  then
		cp "${input}" "${dir}/${base}_TEMP.${ext}"
		rm "${input}"

		msg=$("${ffmpeg_bin}" -i "${dir}/${base}_TEMP.${ext}" -filter:v "${value}" -c:a copy "${input}" 2>&1)

		rm "${dir}/${base}_TEMP.${ext}"
	else
		msg=$("${ffmpeg_bin}" -i "${input}" -filter:v "${value}" -c:a copy "${dir}/${base}_rotated.${ext}" 2>&1)
	fi

	return $?
}

run_rotate () {
	if [ "${overwrite}" = true ];  then
		cp "${input}" "${dir}/${base}_TEMP.${ext}"
		rm "${input}"

		msg=$("${ffmpeg_bin}" -display_rotation "${angle}" -i "${dir}/${base}_TEMP.${ext}" -c:a copy "${input}" 2>&1)

		rm "${dir}/${base}_TEMP.${ext}"
	else
		msg=$("${ffmpeg_bin}" -display_rotation "${angle}" -i "${input}" -c:a copy "${dir}/${base}_rotated.${ext}" 2>&1)
	fi

	return $?
}


########################################

detect_gpu_h264_hevc () {
	gpu_choice=$(lspci | grep -i '.* vga .*')

	if [[ "{$gpu_choice}" == *'UHD Graphics'* ]]; then
		gpu_list="${gpu_list}Intel "
		def_encoder="Intel"
	fi
	if [[ "{$gpu_choice}" == *'GeForce'* ]]; then
		gpu_list="${gpu_list}Nvidia "
		def_encoder="Nvidia"
	fi
	gpu_list="${gpu_list}CPU"
}

detect_gpu_vp9 () {
	gpu_choice=$(lspci | grep -i '.* vga .*')

	if [[ "{$gpu_choice}" == *'UHD Graphics'* ]]; then
		gpu_list="${gpu_list}Intel "
		def_encoder="Intel"
	fi
	gpu_list="${gpu_list}CPU"
}

do_you_want_to_overwrite () {
	"${kdialog_bin}" --icon configure --title "${!msg_title}" --warningyesno "${msg_common_overwrite_text}" && overwrite=true || \
		{
			[ $? -eq 1 ] && overwrite=false || \
				{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
		}
}

manage_input_separately () {
	[ ${#} -lt 1 ] && help
	[ ${#} -gt 1 ] && multiple_files=true

    # update messages with presently available vars
    load_language

	type run_${action} > /dev/null || \
		{ "${kdialog_bin}" --title "${msg_common_software_not_found_title}" --icon configure --error "${msg_common_action_not_found_text}" && exit 2; }

	[ "${ask_overwrite}" = true ] && do_you_want_to_overwrite

	quantity=$#
	dbus_ref=$(kdialog --icon configure --title "${!msg_title}" --progressbar "${msg_common_start}" $quantity)
	processed=0

	for input in "$@"; do
		## Check if window has been closed w. cancel / alt + f4...
		if [ "$?" = 0 ]; then
			dir=$(dirname -- "${input}")
			name="${input##*/}"
			base="${name%.*}"
			ext="${name##*.}"

			processed=$(($processed + 1))
			load_language			
			[ ! -f "${input}" ] && "${kdialog_bin}" --title --icon configure "${!msg_title}" --error "${msg_common_file_not_found}" && break
			qdbus $dbus_ref setLabelText "${msg_common_progress_text}"

			msg_finish_title=msg_${action}_finish_title
			run_${action} && \				
				"${kdialog_bin}" --title "${!msg_finish_title}" --passivepopup "${msg_common_finish_ok}" 5 || \
				{ qdbus $dbus_ref close; "${kdialog_bin}" --icon configure --title "${!msg_finish_title}" --detailederror "${msg_common_finish_error}" "${msg}"; exit 2; }
			
			qdbus $dbus_ref org.freedesktop.DBus.Properties.Set org.kde.kdialog.ProgressDialog value $processed
		else	
			"${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2;
		fi
	done

	qdbus $dbus_ref close
}

manage_input_at_once () {
	[ ${#} -lt 1 ] && help

	dir=$(dirname -- "${1}")
	name="${1##*/}"
	load_language

	msg_finish_title=msg_${action}_finish_title
	run_${action} "${@}" && \
		"${kdialog_bin}" --title "${!msg_finish_title}" --passivepopup "${msg_common_finish_ok}" 5 || \
		{ qdbus $dbus_ref close; "${kdialog_bin}" --icon configure --title "${!msg_finish_title}" --detailederror "${msg_common_finish_error}" "${msg}"; exit 2; }

}

######################################## Set compress and resize input


set_reencode_pro () {
	
	shift
	value="${1}"
	auto="${value//*?-/}"

	load_language

	if [ "${value}" = "custom" ] && { formats; exit 0; }; then
		vcodec=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --inputbox "${msg_codec_encode_input_text}") || \
			{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
		profile=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --inputbox "${msg_profile_encode_input_text}") || \
			{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
	else
		vcodec="${value//-?*/}"
		profile="${value//*?-/}"
	fi	
	
	ask_overwrite=true

	manage_input_separately "${@}"
}

set_reencode_h264 () {
	
	shift
	value="${1}"
	vcodec="${value}"

	############### Detect compatible GPU and choose which encode protocol is used. Important values are decided fron this function

	detect_gpu_h264_hevc
	load_language

	if [ "${gpu_list}" != "CPU" ]; then
		encoder=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --combobox "${msg_gpu_encode_input_text}" $gpu_list) || \
			{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
		if [ "${encoder}" = "" ]; then encoder="${def_encoder}"
		fi
	
		if [ "${encoder}" = "Intel" ]; then
			vcodec="h264_qsv"
		elif [ "${encoder}" = "Nvidia" ]; then
			vcodec="h264_nvenc"
		elif [ "${encoder}" = "CPU" ]; then
			vcodec="libx264"
		fi
	fi

	############### Default values depending of the protocol

	if [ "${vcodec}" = "h264_qsv" ]; then
		def_quality=medium
		quality_list=("veryfast faster fast medium slow slower veryslow")
	elif [ "${vcodec}" = "h264_nvenc" ]; then
		def_quality=p4
		quality_list=("p1 p2 p3 p4 p5 p6 p7")
	elif [ "${vcodec}" = "libx264" ]; then
		def_bitrate=23; def_quality=medium;
		quality_list=("ultrafast superfast veryfast faster fast medium slow slower veryslow")
	fi
	
	############### Ask for tweaking depending of the protocol

	valid_value="false"

	min_bitrate=0; max_bitrate=51;
	load_language

	if [ "${vcodec}" = "libx264" ]; then

		while [ "${valid_value}" = "false" ]; do
			bitrate=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --inputbox "${msg_bitrate_encode_input_text}" $def_bitrate) || \
				{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }

			valid_value="true"

			if [[ ! $bitrate =~ ^[0-9]+$ ]] || [ $bitrate -lt $min_bitrate ] || [ $bitrate -gt $max_bitrate ]; then
				"${kdialog_bin}" --title --icon configure "${!msg_title}" --error "${msg_invalid_value}"
				valid_value="false"
			fi
		done
	
	opt_bitrate=" -crf $bitrate"
	fi
	
	quality=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --combobox "${msg_quality_encode_input_text}" $quality_list) || \
		{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
	if [ "${quality}" = "" ]; then quality="${def_quality}" 
	fi

	ask_overwrite=true

	manage_input_separately "${@}"
}

set_reencode_hevc () {
	
	shift
	value="${1}"
	vcodec="${value}"

	############### Detect compatible GPU and choose which encode protocol is used. Important values are decided fron this function

	detect_gpu_h264_hevc
	load_language
	
	if [ "${gpu_list}" != "CPU" ]; then
		encoder=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --combobox "${msg_gpu_encode_input_text}" $gpu_list) || \
			{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
		if [ "${encoder}" = "" ]; then encoder="${def_encoder}"
		fi
	
		if [ "${encoder}" = "Intel" ]; then
			vcodec="hevc_qsv"
		elif [ "${encoder}" = "Nvidia" ]; then
			vcodec="hevc_nvenc"
		elif [ "${encoder}" = "CPU" ]; then
			vcodec="libx265"
		fi
	fi

	############### Default values depending of the protocol

	if [ "${vcodec}" = "hevc_qsv" ]; then
		def_quality=medium
		quality_list=("veryfast faster fast medium slow slower veryslow")
	elif [ "${vcodec}" = "hevc_nvenc" ]; then
		def_quality=p4
		quality_list=("p1 p2 p3 p4 p5 p6 p7")
	elif [ "${vcodec}" = "libx265" ]; then
		def_bitrate=28; def_quality=medium;
		quality_list=("ultrafast superfast veryfast faster fast medium slow slower veryslow")
	fi
	
	############### Ask for tweaking depending of the protocol

	valid_value="false"

	min_bitrate=0; max_bitrate=51;
	load_language

	if [ "${vcodec}" = "libx265" ]; then

		while [ "${valid_value}" = "false" ]; do
			bitrate=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --inputbox "${msg_bitrate_encode_input_text}" $def_bitrate) || \
				{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }

			valid_value="true"

			if [[ ! $bitrate =~ ^[0-9]+$ ]] || [ $bitrate -lt $min_bitrate ] || [ $bitrate -gt $max_bitrate ]; then
				"${kdialog_bin}" --title --icon configure "${!msg_title}" --error "${msg_invalid_value}"
				valid_value="false"
			fi
		done
	
	opt_bitrate=" -crf $bitrate"
	fi
	
	quality=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --combobox "${msg_quality_encode_input_text}" $quality_list) || \
		{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
	if [ "${quality}" = "" ]; then quality="${def_quality}" 
	fi

	ask_overwrite=true

	manage_input_separately "${@}"
}

set_reencode_vp9 () {

	shift
	value="${1}"
	vcodec="${value}"

	############### Detect compatible GPU and choose which encode protocol is used. Important values are decided fron this function

	detect_gpu_vp9
	load_language
	
	if [ "${gpu_list}" != "CPU" ]; then
		encoder=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --combobox "${msg_gpu_encode_input_text}" $gpu_list) || \
			{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
		if [ "${encoder}" = "" ]; then encoder="${def_encoder}"
		fi
	
		if [ "${encoder}" = "Intel" ]; then
			vcodec="vp9_qsv"
		elif [ "${encoder}" = "CPU" ]; then
			vcodec="libvpx-vp9"
		fi
	fi

	############### Default values depending of the protocol

	if [ "${vcodec}" = "vp9_qsv" ]; then
		def_quality=medium; multithread=0;
		quality_list=("veryfast faster fast medium slow slower veryslow")
	elif [ "${vcodec}" = "libvpx-vp9" ]; then
		def_bitrate=31; def_quality=good; multithread=0;
		quality_list=("best good realtime")
	fi

	############### Ask for tweaking depending of the protocol

	valid_value="false"

	min_bitrate=0; max_bitrate=63;
	load_language

	if [ "${vcodec}" = "libvpx-vp9" ]; then
		while [ "${valid_value}" = "false" ]; do
			bitrate=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --inputbox "${msg_bitrate_encode_input_text}" $def_bitrate) || \
				{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }

			valid_value="true"

			if [[ ! $bitrate =~ ^[0-9]+$ ]] || [ $bitrate -lt $min_bitrate ] || [ $bitrate -gt $max_bitrate ]; then
				"${kdialog_bin}" --title --icon configure "${!msg_title}" --error "${msg_invalid_value}"
				valid_value="false"
			fi
		done
	
	opt_bitrate=" -crf $bitrate"
	fi

	quality=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --combobox "${msg_quality_encode_input_text}" $quality_list) || \
		{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
	if [ "${quality}" = "" ]; then quality="${def_quality}"
	fi

	if [ "${vcodec}" = "libvpx-vp9" ]; then	
		"${kdialog_bin}" --icon configure --title "${!msg_title}" --yesno "${msg_multithread_input_text}" && multithread=1 || \
			{ [ $? -eq 1 ] && multithread=0 || \
					{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
			}
	fi

	ask_overwrite=true

	manage_input_separately "${@}"
}

set_rewrap () {
	value="${1}"
	shift

	if [ "${value}" = "custom" ]; then
		format=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --inputbox "${msg_rewrap_format_input_text}") || \
			{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
	else
		format="${value}"
	fi

	for arg in "$@"; do
		arg_ext="${arg##*.}"
		[ "${arg_ext}" = "${format}" ] && ask_overwrite=true && break
	done

	manage_input_separately "${@}"
}

set_interpolate () {
	def_multi=2
	multiplicator_list=("2 4 6 8")

	multiplicator=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --combobox "${msg_interpolate_multiplicator_input_text}" ${multiplicator_list} ) || \
		{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
	if [ "${multiplicator}" = "" ]; then multiplicator="${def_multi}" 
	fi

	for arg in "$@"; do
		arg_ext="${arg##*.}"
		[ "${arg_ext}" = "${format}" ] && ask_overwrite=true && break
	done

	manage_input_separately "${@}"
}

set_overturn () {
	value="${1}"
	shift

	for arg in "$@"; do
		arg_ext="${arg##*.}"
		[ "${arg_ext}" = "${format}" ] && ask_overwrite=true && break
	done

	manage_input_separately "${@}"
}

set_rotate () {
	value="${1}"
	shift

	if [ "${value}" = "custom" ]; then
		angle=$("${kdialog_bin}" --icon configure --title "${!msg_title}" --inputbox "${msg_rotate_angle_input_text}") || \
			{ "${kdialog_bin}" --title "${!msg_title}" --passivepopup "${msg_common_abort}" 5 && exit 2; }
	else
		angle="${value}"
	fi

	for arg in "$@"; do
		arg_ext="${arg##*.}"
		[ "${arg_ext}" = "${format}" ] && ask_overwrite=true && break
	done

	manage_input_separately "${@}"
}

set_horizontal_disassemble () {
	value="${1}"
	shift

	manage_input_separately "${@}"
}


################################################################################

[ "${1}" = "-h" ] || [ "${1}" = "--help" ] || [ ${#} -lt 2 ] && help

kdialog_bin=$(which kdialog)
[ -z "${kdialog_bin}" ] && echo "kdialog not found!" && exit 1

ffmpeg_bin=$(which ffmpeg)
[ -z "${ffmpeg_bin}" ] && \
	"${kdialog_bin}" --icon configure --title "${msg_common_software_not_found_title}" --error "${msg_common_ffmpeg_not_found_text}" && exit 2

action="${1}"
shift



load_language
msg_title=msg_${action}_title
msg_finish_title=msg_${action}_finish_title

type set_${action} &> /dev/null || \
	{ "${kdialog_bin}" --icon configure --title "${msg_common_software_not_found_title}" --error "${msg_common_action_not_found_text}" && exit 3; }

ask_overwrite=false
set_${action} "${@}"

exit 0
